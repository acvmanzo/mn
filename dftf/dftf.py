#This module contains functions used for analyzing videos of flies drinking. In particular,
#it is useful for measuring the frequency of pumping when the fly is fed 
#colored dye. 


#This module is used for analyzing files in the file structure generated by the ImageJ macro 
#'automeasure', which follows this general outline:

#experiment//
    #experiment_fmfs//
    #experiment_wbr//
    #data//
        #movie1//
            #results1.txt
            #roi1.zip
            #slice712draw.jpg
            #params
        #movie2//
            #results1.txt
            #roi1.zip
            #slice205draw.jpg
    #results*//
    #summary*//

#Most of the programs should be run from either the data folder or the individual movie folders. 
#Starred folders are created by functions in this script.

import numpy as np
import os
import matplotlib
import matplotlib.pyplot as plt
import matplotlib.mlab as mlab
import glob
import mn.plot.genplotlib as genplotlib
from mn.cmn.cmn import *

# Changes default settings for the matplotlib plots.
matplotlib.rc('axes', titlesize='medium')
matplotlib.rc('xtick', labelsize='small')
matplotlib.rc('ytick', labelsize='small')
matplotlib.rc('legend', fontsize='x-small')
matplotlib.rc('savefig', dpi=150)
matplotlib.rc('figure.subplot', left=0.1, right=0.95, hspace=0.25, wspace=0.25)



def loadresultsfile(fname, colname):
    """Returns a numpy array from data in the ImageJ-generated file 'fname', which is a text file 
    containing the Mean ROI intensity for each frame of an image sequence.
    
    This function is meant to be used with a file generated by the ImageJ function "multimeasure", 
    usually with the ImageJ custom macro "automeasure.txt".
    """
    
    f = open(fname)
    a = f.readline().split()
    f.close()
    b = []
    #Specifically imports the data under the "Mean1" column.
    for x in a: 
        b.append(x.find(colname))
    col = b.index(0) + 1
    return(np.loadtxt(fname, skiprows=1, usecols=(col,)))
    
    #for x in a:
        #return(np.loadtxt(fname, skiprows=1, usecols=(1,)))



def getflypic(roiname):
    """Returns the image in the current folder whose filename begins with the word 'slice'.
    
    In particular, it is meant to be used with the jpg generated by the ImageJ custom macro 
    'automeasure.txt'.
    """
    
    flypics = glob.glob('{0}.jpg'.format(roiname))
    return(plt.imread(flypics[0]))
    

#~ def hmsub(trace):
    #~ """Mean-subtracts and then multiplies a trace (a numpy array) with a Hamming function of
    #~the same size as the ~ trace."""
    #~ 
    #~ return(np.hamming(np.size(trace))*(trace - np.mean(trace)))


def load_keys(file):
    K = []
    with open(file) as f:
        for l in f:
            K = l.strip('\n').split(',')
    return(K)
    

def dft(trace, dftsize):
    """Finds the discrete fourier transform of size 'dftsize' of a trace using the np.fft 
    function."""
    return(np.abs(np.fft.fft(trace, dftsize)))




class TraceData:
    """This class provides functions for processing a numpy array generated by ImageJ's custom 
    automeasure macro.
    
    The numpy array is a list of numbers representing the mean intensity of an ROI; this data is 
    saved in the file 'fname'. 'Paramsfile' is the file containing parameters needed for further 
    analyzing the data, and is generated by the python code 'genparams.py'. The first column of 
    'paramsfile' contains the variable names and the second column contains the values.'Paramsfile' 
    requires the following parameters to be specified:
        f1: start frame (used to select the frames for dft analysis)
        f2: end frame; a fixed number of frames from f1 (usually 300); f1 and f2 specify the 
            selection of frames used for dft analysis)
        sample_length: the number of frames used for DFT analysis (f2-f1 = sample_length)
        f_end: f1 to f_end specifies frames that are valid for dft analysis
        fps: sampling frequency of the movie being analyzed
    """
             
    
    def __init__(self, fname, paramsfile, corrparamsfile, colname='Mean1'):
        self.fname = fname
        self.paramsfile = paramsfile
        self.corrparamsfile = corrparamsfile
        self.colname = colname
        
 
    def Processrawtrace(self, dftsize, hz_bound1, hz_bound2):
        """This method returns a dictionary containing the raw mean intensity trace as well as 
        processed traces. dftsize specifies the size of the dft used for the fft function.
        
        'rawtrace' refers to the trace that is loaded from the ImageJ results file.
        'seltrace' refers to the frames of 'rawtrace' that beings with frame f1 and ends with 
        frame f2.
        'hmsubtrace' refers to the 'seltrace' after it has been mean-subtracted and hamming-multplied 
        'dfttrace' refers to the fourier transform of the 'seltrace'
        'dftnormtrace' is the normalized fourier transform.
        'dftnormtrunctrace' is the normalized fourier transform truncated so that only half of the 
        transform is shown.
        'peakf' is the peak frequency of the dftnormtrunctrace.
        'hz_bound1' is the lower bound used for identifying the peak frequency
        'hz_bound2' is the upper bound used for identifying the peak frequency (sometimes these 
        need to be tweaked using dftfcorr to get the correct peak frequency)
        """
        
        
        
        tracedict = {}
        
        f = open(self.paramsfile)
        i = f.readline()
        f.close()
        
        if len(i.split(',')) == 2:
            for l in open(self.paramsfile):
                tracedict[l.split(',')[0]] = (l.split(',')[1].strip('\n'))
        
        if len(i.split()) == 2:
            for l in open(self.paramsfile):
                tracedict[l.split()[0]] = (l.split()[1].strip('\n'))
        
        
        tracedict['dftsize'] = dftsize
        tracedict['colname'] = self.colname
        tracedict['roiname'] = self.colname.replace('Mean', 'roi')
        tracedict['moviename'] = os.path.basename(os.path.abspath('.'))
        
        tracedict['f1'] = int(tracedict['f1'])
        tracedict['f2'] = int(tracedict['f2'])
        tracedict['fps'] = float(tracedict['fps'])
        tracedict['f_end'] = int(tracedict['f_end'])
        tracedict['sample_length'] = int(tracedict['sample_length'])
        
        try:
            tracedict['flypic'] = getflypic(tracedict['roiname'])  
        except IndexError:
            pass
        
        tracedict['rawtrace'] = loadresultsfile(self.fname, self.colname)
        tracedict['seltrace'] = tracedict['rawtrace'][tracedict['f1']:tracedict['f2']]
        tracedict['hmsubtrace'] = hmsub(tracedict['seltrace'])
        tracedict['dfttrace'] = dft(tracedict['hmsubtrace'], dftsize)
        tracedict['dftnormtrace'] = tracedict['dfttrace']/max(tracedict['dfttrace'])
        tracedict['dftnormtrunctrace'] = tracedict['dftnormtrace'][0:dftsize/2]
        
        # If corrparams exist (which contains the manually selected lower and upper frequency 
        #~ bounds for finding the peak frequency), then the script loads this file. If not, it 
        #~ uses the default values set while running the script.
        if os.path.exists(self.corrparamsfile) == True:
            with open(self.corrparamsfile) as f:
                for l in f:
                    try:
                        tracedict[l.split(',')[0]] = float(l.split(',')[1].strip('n'))
                    except ValueError:
                        tracedict[l.split(',')[0]] = (l.split(',')[1].strip('n'))
        else: 
            tracedict['hz_bound1'] = hz_bound1
            tracedict['hz_bound2'] = hz_bound2
               
        
        sample_bound1 = tracedict['hz_bound1']*(dftsize/tracedict['fps'])
        
        try:
            sample_bound2 = tracedict['hz_bound2']*(dftsize/tracedict['fps'])
        except TypeError:
            sample_bound2 = -1
        
        #Finds the argument of the max value from hzshift to the end.
        tracedict['argmax'] = np.argmax(tracedict['dftnormtrunctrace'][sample_bound1:sample_bound2])
        tracedict['samplemax'] = np.max(tracedict['dftnormtrunctrace'][sample_bound1:sample_bound2])
        #Finds the peak frequency by finding m + (amount shifted from above) multiplied by the 
        #conversion factor for # samples/frequency (dftsize/fps).
        tracedict['peakf'] = (tracedict['argmax']+sample_bound1)*((tracedict['fps'])/dftsize)
        
        return tracedict
        
        


def plotrawtrace(td, subplotn=111):
    """Plots the original raw trace; td is a dictionary generated using method 
    TraceData.Processrawtrace.."""
    
    ax = plt.subplot(subplotn)
    plt.plot(td['rawtrace'])
    plt.title('Raw Trace')
    ### Changes tick interval to be 250.
    ax.xaxis.set_major_locator(matplotlib.ticker.MaxNLocator(4))
    
    

def plotseltrace(td, subplotn=111):
    """Plots the selected trace; td is a dictionary generated using method 
    TraceData.Processrawtrace.."""
    
    ax = plt.subplot(subplotn)
    plt.plot(td['seltrace'], label='frames {0} to {1}'.format(td['f1'], 
    td['f2']))
    plt.legend()
    plt.title('Selection: {0} frames'.format(td['f2']-td['f1']))
    ### Changes tick interval to be 250.
    ax.xaxis.set_major_locator(matplotlib.ticker.MaxNLocator(4))


def plothmsubtrace(td, subplotn=111):
    """Plots the mean-subtracted and hamming-multiplied trace; td is a dictionary generated using method TraceData.Processrawtrace.
    """
    
    ax = plt.subplot(subplotn)
    plt.plot(td['hmsubtrace'])
    plt.title('Ham*meansub')
    ### Changes tick interval to be 250.
    ax.xaxis.set_major_locator(matplotlib.ticker.MaxNLocator(4))



def plotdfttrace(td, subplotn=111):
    """Plots the dft trace; td is a dictionary generated using method 
    TraceData.Processrawtrace."""
    
    ax = plt.subplot(subplotn)
    plt.plot(td['dfttrace'])
    plt.title('DFT')
    ### Changes tick interval to be 250.
    ax.xaxis.set_major_locator(matplotlib.ticker.MaxNLocator(4))


def plotdftnormtrace(td, subplotn=111):
    """Plots the normalized dft trace; td is a dictionary generated using method 
    TraceData.Processrawtrace."""
    
    ax = plt.subplot(subplotn)
    plt.plot(td['dftnormtrace'])
    plt.title('Norm DFT')
    ### Changes tick interval to be 250.
    ax.xaxis.set_major_locator(matplotlib.ticker.MaxNLocator(4))


def plotdftnormtrunctrace(td, subplotn=111):
    """Plots the normalized and truncated dft trace; td is a dictionary generated using method 
    TraceData.Processrawtrace."""
    
    m = td['peakf']
    plt.subplot(subplotn)
    xpoints = np.linspace(0, td['fps']/2, td['dftsize']/2)
    plt.plot(xpoints, td['dftnormtrunctrace'], label='peak f = {0}'.format(m))
    plt.plot(td['peakf'], td['samplemax'], 'ro')
    plt.legend()
    plt.xlabel('Hz')
    plt.title('Norm + Trunc DFT')
    
         
def plotflypic(td, subplotn=111):
    """Plots the picture of the ROI and the fly; td is a dictionary generated using method 
    TraceData.Processrawtrace."""
    
    ax = plt.subplot(subplotn)
    ### Removes tick marks and labels.
    ax.axes.xaxis.set_major_locator(matplotlib.ticker.NullLocator())
    ax.axes.yaxis.set_major_locator(matplotlib.ticker.NullLocator())
    plt.imshow(np.rot90(np.rot90(td['flypic'])))
    plt.title(str(td['condition']))
    

def plotalltraces(td):
    """Plots all traces and the fly picture; td is a dictionary generated using method 
    TraceData.Processrawtrace."""
    
    plotrawtrace(td, 231)
    plotseltrace(td, 232)
    plothmsubtrace(td, 233)
    plotdfttrace(td, 234)
    plotdftnormtrunctrace(td, 235)
    plotflypic(td, 236)


def plotspecgram(td, nfft=256):
    """Plots the spectrogram of the raw trace; td is a dictionary generated using method 
    TraceData.Processrawtrace."""
    
    
    (Pxx, freqs, bins, im) = plt.specgram(td['rawtrace'], NFFT=nfft, Fs=td['fps'],
            detrend=mlab.detrend_mean, noverlap=nfft/2, pad_to=nfft)
    plt.axvline(x=td['f1']/td['fps'], c='k')
    plt.axvline(x=td['f2']/td['fps'], c='k')
    plt.axvline(x=td['f_end']/td['fps'], c='k', ls='--')
    plt.title('Spectrogram of raw trace')
    plt.xlabel('Time')
    plt.ylabel('Hz')
    

#~ def makenewdir(newdir):
    #~ """Makes the new directory 'newdir' without raising an exception if 'newdir' already exists."""
    #~ 
    #~ try:
        #~ os.makedirs(newdir)
    #~ except OSError as e:
        #~ if e.errno == 17:
            #~ pass  

def genfigname(suffix, dpath='.'):
    """Returns the string "movie_suffix' where 'movie' is the basename of the folder 'dpath' 
    and 'suffix' is the first argument. Should be run from inside a movie folder.
    
    For instance, if dpath is 'mov_20100817_172325' then genfigname('DFT') would 
    return the string 'mov_20100817_172325_DFT'.
    """ 
    
    moviename = (os.path.basename(os.path.abspath(dpath)))
    fullname = '{0}_{1}'.format(moviename, suffix)
    return(fullname)


def resfolder(dpath='.'):
    """Returns a new path to a folder in the results folder which has the same basename as the 
    path 'dpath'. 
    
    For instance, if dpath is 
    '/home/andrea/Documents/lab/motor_neurons/lof/2010-0817_tnt/data/mov_20100817_172325', 
    then resfolder() returns 
    '/home/andrea/Documents/lab/motor_neurons/lof/2010-0817_tnt/results/mov_20100817_172325'.
    """
    
    a = os.path.dirname(os.path.abspath('../{0}'.format(dpath)))
    b = os.path.basename(os.path.abspath(dpath))
    resdir = os.path.join(a, 'results', b)
    return(resdir)
    
    

def savetrace(suffix):
    """Saves the current figure under the filename 'movie_suffix' into the appropriate movie folder in the 
    results folder.  
    
    For example, if you run savetrace('test') from the folder
    '/home/andrea/Documents/lab/test2/data/mov_20100819_174601', it will save the current figure into the folder 
    '/home/andrea/Documents/lab/test2/results/mov_20100819_174601'. The name of the file would be 
    'mov_20100819_174601_test.png'
    """
    
    savedfigname = genfigname(suffix)
    respath = os.path.join(resfolder(), savedfigname)
    makenewdir(resfolder('.'))
    plt.savefig(respath)
    
    

def savetracesumm(suffix, dpath='.',  moviefold = 'summary/dftf_movies/'):
    """Saves the current figure into the summary folder with the filename 'movie_suffix'. 
    
    For instance, if you run savetracesumm(summ) in the folder
    '/home/andrea/Documents/lab/test2/data/mov_20100819_174601', 
    then the figure is saved with the filename 'mov_20100819_174601_summ.png' in the folder
    '/home/andrea/Documents/lab/test2/summary'.
    """
    
    figname = genfigname(suffix)
    a = os.path.dirname(os.path.abspath('../{0}'.format(dpath)))
    resdir = os.path.join(a, moviefold)
    makenewdir(resdir)
    respath = os.path.join(resdir, figname)
    plt.savefig(respath)


def savetracecorr(suffix, dpath='.'):
    """Saves the current figure into the corrections folder with the filename 'movie_suffix'. 
    
    For instance, if you run savetracesumm(summ) in the folder
    '/home/andrea/Documents/lab/test2/data/mov_20100819_174601', 
    then the figure is saved with the filename 'mov_20100819_174601_summ.png' in the folder
    '/home/andrea/Documents/lab/test2/summary'.
    """
    
    figname = genfigname(suffix)
    a = os.path.dirname(os.path.abspath('../{0}'.format(dpath)))
    resdir = os.path.join(a, 'summary/corrections/movie_summaries/')
    makenewdir(resdir)
    respath = os.path.join(resdir, figname)
    plt.savefig(respath)


def plotandsavealltraces(td, fdir='.'):
    """Plots all traces in one figure and saves the figure in the results folder and the summary 
    folder. Also plots and saves the spectrogram.
    """
    
    os.chdir(fdir)
    roiname = td['roiname']
    colname = td['colname']
    #if os.path.exists('params') == True:
        #rawtracedata = TraceData('results1.txt', 'params', colname)
        #td = rawtracedata.Processrawtrace(10000)
    if os.path.isfile('params') == True:
        plotalltraces(td)
        savetrace(roiname+'_allDFT')
        savetracesumm(roiname+'_allDFT')
        plt.close()
        plotspecgram(td)
        savetrace(roiname+'_spec')
        savetracesumm(roiname+'_spec')
        plt.close()
        plotdftnormtrunctrace(td)
        savetrace(roiname+'_DFT')
        savetracesumm(roiname+'_DFT')
        plt.close()
    
def plotandsaveallcorrtraces(td, fdir='.'):
    """Plots all traces in one figure and saves the figure in the results folder and the summary 
    folder. Also plots and saves the spectrogram.
    """
    
    os.chdir(fdir)
    roiname = td['roiname']
    colname = td['colname']
    #if os.path.exists('params') == True:
        #rawtracedata = TraceData('results1.txt', 'params', colname)
        #td = rawtracedata.Processrawtrace(10000)
    if os.path.isfile('corrparams') == True:
        plotalltraces(td)
        savetrace(roiname+'_allDFT')
        savetracesumm(roiname+'_allDFT')
        savetracecorr(roiname+'_allDFT')
        plt.close()
        plotdftnormtrunctrace(td)
        savetrace(roiname+'_DFT')
        savetracesumm(roiname+'_DFT')
        savetracecorr(roiname+'_DFT')
        plt.close()
    

#def plotandsavedfttrace(trace, fdir='.'):
    #os.chdir(fdir)
    #if os.path.exists('params') == True:
        #rawtracedata = TraceData(fname='results1.txt', paramsfile='params')
        #td = rawtracedata.Processrawtrace(10000)
        #if os.path.isfile('params') == True:
            #plotseltraces(td)
            #savetrace('DFTall')
            #savetracesumm('DFTall')
            #plt.close()
            #plotspecgram(td)
            #savetrace('spec')
            #savetracesumm('spec')
            #plt.close()




def deloldsummfile(colname, fdir):
    """Deletes an old summary file; run from data folder."""
    
    peakffname = genpeakffname_roi(colname, fdir)

    #print(peakffname)
    if os.path.exists(peakffname) == True:
        os.remove(peakffname)


def writepeakf(fdir='.'):
    """Writes the peak frequency into a csv text file. Run from a data/movie folder. 
    
    If dpath is 
    '/home/andrea/Documents/lab/test2/data/mov_20100819_174601', then the output file contains:
    
    Movie,Peak frequency,Condition
    movie,7.326,112204xTNT
    
    The name of the output file is 'peakf.txt', and it is saved into the summary folder.
    
    Note that this script will continue to append lines to the peakf.txt file regardless of how 
    often it's been previously run, so check the peakf.txt file before further analysis to ensure 
    that each movie is represented only once.    
    """
    
    os.chdir(fdir)
    
    if os.path.exists('params') == True:
        rawtracedata = TraceData(fname='results1.txt', paramsfile='params')
        td = rawtracedata.Processrawtrace(10000)
        
        
        resdir = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(fdir))), 
        'summary')
        makenewdir(resdir)
        peakffname = '{0}/peakf.txt'.format(resdir)
        
        
        if os.path.isfile(peakffname) != True:
            f = open(peakffname, 'w')
            f.write('Movie' + ',' + 'Peak frequency' + ',' + 'Condition' + '\n')
            f.close()
        
        f = open(peakffname, 'a')
        m = str(td['peakf'])
        c = str(td['condition'])
        #f1 = str(trace.framenum[0])
        #f2 = str(trace.framenum[1])
        f.write(os.path.basename(os.path.abspath(fdir)) + ',' + m + ',' + c + '\n')
        f.close()        
             
        x = os.path.abspath(fdir)
        matlabdir = '/home/andrea/Documents/lab/matlab'
        exptname = os.path.basename(os.path.dirname(os.path.dirname(x)))
        matlab_expt_dir = os.path.join(matlabdir, exptname)
        makenewdir(matlab_expt_dir)
        peakfmfname = os.path.join(matlab_expt_dir, 'peakfm.txt')
        
        if os.path.isfile(peakfmfname) != True:
            g = open(peakfmfname, 'w')
            g.close()
        
        g = open(peakfmfname, 'a')
        g.write('c'+ c + ',' + m + '\n')
        g.close()


def writepeakf_d(td, fdir='.'):
    """Similar to writepeakf, but the dictionary is one of the arguments."""
    
    os.chdir(fdir)
    
    peakffname = genpeakffname_movie(td, fdir='..')
    
    if os.path.isfile(peakffname) != True:
        f = open(peakffname, 'w')
        f.write('Movie' + ',' + 'Peak frequency' + ',' + 'Condition' + '\n')
        f.close()
    
    f = open(peakffname, 'a')
    m = str(td['peakf'])
    c = str(td['condition'])
    #f1 = str(trace.framenum[0])
    #f2 = str(trace.framenum[1])
    f.write(td['moviename'] + ',' + m + ',' + c + '\n')
    f.close()        
         

def writecorrpeakf_d(td, fdir='.'):
    """Writes to the summary/corrections directory."""
    
    os.chdir(fdir)
    
    peakffname = gencorrpeakffname_movie(td, fdir='..')
    
    if os.path.isfile(peakffname) != True:
        f = open(peakffname, 'w')
        f.write('Movie' + ',' + 'Peak frequency' + ',' + 'Condition' + '\n')
        f.close()
    
    f = open(peakffname, 'a')
    m = str(td['peakf'])
    c = str(td['condition'])
    #f1 = str(trace.framenum[0])
    #f2 = str(trace.framenum[1])
    f.write(td['moviename'] + ',' + m + ',' + c + '\n')
    f.close()  


def writecorrparams(td, fdir='.'):
    """Writes the corrparams file."""
    
    f = open('corrparams', 'a')
    f.write('hz_bound1,' + str(td['hz_bound1']) + '\n')
    f.write('hz_bound2,' + str(td['hz_bound2']))
    f.close()
    

def batch_dftf_wp_plot():
    os.chdir(fdir)
    names = glob.iglob('*')
    # Absolute path rather than relative path allows changing of directories in fn_name.
    names = sorted([os.path.abspath(name) for name in names])
    for name in names:
        print os.path.basename(name)
        f(name)

def genpeakffname_roi(colname, fdir='.'):
    """Run from data folder"""
    
    resdir = os.path.join(os.path.dirname(os.path.abspath(fdir)), 'summary')
    peakffname = '{0}/peakf_{1}.txt'.format(resdir, colname)
    return(peakffname)
    

def genpeakffname_movie(td, fdir='.'):
    """Returns a string of the path for a new peakf.txt file. Should be run from the /data folder.
    
    If fdir is '/home/andrea/Documents/lab/test2/summary', then returns the string 
    '/home/andrea/Documents/lab/test2/summary/peakf.txt'. 
    """
    
    resdir = os.path.join(os.path.dirname(os.path.abspath(fdir)), 'summary')
    peakffname = '{0}/peakf_{1}.txt'.format(resdir, td['roiname'])
    return(peakffname)
    

def gencorrpeakffname_movie(td, fdir='.'):
    """Returns a string of the path for the corrected peakf.txt file. Should be run from the /data folder.
    
    If fdir is '/home/andrea/Documents/lab/test2/summary', then returns the string 
    '/home/andrea/Documents/lab/test2/summary/corrections/corrpeakf.txt'. 
    """
    
    resdir = os.path.join(os.path.dirname(os.path.abspath(fdir)), 'summary/corrections')
    peakffname = '{0}/peakf_{1}_corr.txt'.format(resdir, td['roiname'])
    return(peakffname)
    
 
    
def batch(f, fdir='.'):
    """Carries out the function 'fn_name' recursively on all files in the directory 'fdir'.
    """
    
    os.chdir(fdir)
    names = glob.iglob('*')
    # Absolute path rather than relative path allows changing of directories in fn_name.
    names = sorted([os.path.abspath(name) for name in names])
    for name in names:
        print os.path.basename(name)
        f(name)


def batch_s(fdir):
    os.chdir(fdir)
    names = glob.iglob('*')
    names = sorted([os.path.abspath(name) for name in names])
    return(names)

    
def savegraph(fname, colname, fdir='.'):
    """Saves graph in the summary directory."""
    
    summdir = os.path.dirname(genpeakffname_roi(colname, fdir))
    bargraphname = '{0}/{1}'.format(summdir, fname)
    plt.savefig(bargraphname)
    plt.close()


def plotandsavebargraph(roiname, keylist, fdir='.', ylim=10):
    """Plots bar graph from data in 'peakf.txt' and saves it in the summary directory. Run from a 
    data/ or summary/ folder."""
    
    dictdata = genplotlib.gendict(genpeakffname_roi(roiname, fdir))
    dictmeans = genplotlib.genlist(dictdata)
    #~ keylist = genplotlib.genkeylist(dictdata)
    genplotlib.plotdata(dictdata, dictmeans, keylist, 'b', ylabel='Hz', ftitle='Mean pumping ' + 
    'frequency '+roiname, ylim=ylim)
    savegraph('dftf_freq_bar_'+roiname, roiname)



def plotandsavescatterplot(roiname, keylist, fdir='.', ylim=10):
    """Plots scatter plot from data in 'peakf.txt' and saves it in the summary directory. Run from a 
    data/ or summary/ folder."""
    
    dictdata = genplotlib.gendict(genpeakffname_roi(roiname, fdir))
    dictmeans = genplotlib.genlist(dictdata)
    #~ keylist = genplotlib.genkeylist(dictdata)
    genplotlib.plotdata(dictdata, dictmeans, keylist, 's', ylabel='Hz', ftitle='Mean pumping ' + 
    'frequency '+roiname, ylim=ylim)
    savegraph('dftf_freq_scatter_'+roiname, roiname)


def plotandsavebargraph_poolrois(fname, keylist, fdir='.', ylim=10):
    """Plots bar graph from data in 'peakf_pooled.txt' and saves it in the summary directory. Run from a 
    data/ or summary/ folder."""
    
    dictdata = genplotlib.gendict(fname)
    dictmeans = genplotlib.genlist(dictdata)
    #~ keylist = genplotlib.genkeylist(dictdata)
    genplotlib.plotdata(dictdata, dictmeans, keylist, 'b', ylabel='Hz', ftitle='Mean frequency', 
    ylim=ylim)
    plt.savefig('dftf_freq_bar_pooled')
    
def plotandsavescatterplot_poolrois(fname, keylist, fdir='.', ylim=10):
    """Plots bar graph from data in 'peakf_pooled.txt' and saves it in the summary directory. Run from a 
    data/ or summary/ folder."""
    
    dictdata = genplotlib.gendict(fname)
    dictmeans = genplotlib.genlist(dictdata)
    #~ keylist = genplotlib.genkeylist(dictdata)
    genplotlib.plotdata(dictdata, dictmeans, keylist, 's', ylabel='Hz', ftitle='Mean frequency', 
    ylim=ylim)
    plt.savefig('dftf_freq_scatter_pooled')


if __name__ == '__main__':
    rawtracedata = TraceData(fname='results1.txt', paramsfile='params', colname='Mean1')
    td = rawtracedata.Processrawtrace(10000)

